// 프로그래밍: 타이핑 및 결과 확인 > 이해하기
using System;

// 파일명과 일치시키는 것을 권장 > 필수는 아님
class HelloWorld 
{
    // svn 코드스니펫 사용 > Main() 생성 가능
    static void Main()
    {
        // System은 생략 가능하다. * using System 코드가 없다면 생략할 수 없다.
        // System.Console.WriteLine("Hello World");

        // 코드스니펫 cw > Console.WriteLine() 생성 가능
        Console.WriteLine("Hello World");
        

        /*

        디버깅을 진행할 경우, 프로젝트 폴더 내에 bin폴더 안에 Debug 안에 디버깅한 .exe 형태의 실행파일이 생긴다.
        릴리즈를 진행할 경우, 프로젝트 폴더 내에 bin폴더 안에 Release 안에 릴리즈된 형태의 실행파일이 생긴다.
        
        Debug, Release의 차이점
        - Release에서는 코드 최적화를 하고 Debug에서는 하지 않는다. 
            > 컴파일러가 판단하여 효율적으로 변경할 수 있는 부분을 자동으로 바꿔준다.
        - Debug모드에서는 컴파일 시 코드의 안정성을 위해 여러 가지 장치를 추가한다.
            > stack 위 아래에 여유 공간을 둔다.
            > 디버깅 정보가 담겨진다.
        - 생성되는 파일의 크기가 다르다.
            > 릴리즈는 최적화, 디버깅은 안전성을 추구
        - 사용되는 런타임 라이브러리가 다르다.
            > 컴파일의 목적이 다르기 때문에 런타임 라이브러리가 다르다.
        - 증분 링크 사용 여부가 다르다.
            > 증분링크(incremental link)는 바이너리를 가능한 빠르게 링크하고자 함수 호출시 직접적인 주소를 참조하지 않고 
              별도의 테이블(ILT, 증분링크테이블)로 관리를 하여 함수가 수정되어 크기가 변하여도 모든 CALL 명령을 찾아 수정하는게 아니고 
              테이블만 변경할수 있도록 하여 링크 속도를 높인다.
            > 링커는 바이너리를 가능한 한 빠르게 링크하기 위해 패딩비트를 사용.
            > 따라서 어떤 함수가 변경되면 링커는 각 비트를 이동시켜서 변경된 부분만 삽입하는 형태가 아니라 그냥 전체를 오버라이드 해버린다.
            > 함수들의 주소들을 테이블 형태로 구성하여 줌으로써 변경한 함수를 호출하는 부분의 코드를 재빌드할 필요 없이 
              함수 주소 테이블만 재빌드 해주는 방식으로 빌드 타임을 줄일 수 있다.
        
        C# 대화형 창 
        - 창 여는법: 보기 - 다른 창 - C# 대화형
        - 프로그램 생성않고 C#문법을 테스트하기 적합함
        - 자바스크립트 콘솔창 느낌 남

        .net 솔루션 기반의 특징 > 시작 개체를 설정해줄 수 있다. (아마 닷넷코어는 안되는듯?)
        - Main()가 여러 개더라도 시작개체를 정하면 해당 클래스의 Main()만 작동한다.


         */

        Console.ReadLine();
    }
}